=BEGIN=ГЕНЕРАТОР УРОВНЕЙ ИГРЫ "СОКОБАН"=BEGIN=
Недопустимые пары:
    lR, rL, uD, dU
=END===ГЕНЕРАТОР УРОВНЕЙ ИГРЫ "СОКОБАН"===END=

%баним состояние если это угол (not goal) и если это клетка рядом со стеной, дволь которой нет конечных состояний и можно двигать коробку только по прямой, ограниченной с двух сторон (можем заранее создать список таких узлов, чтобы каждый раз не проверять, а проверять только динамическое появление таких узлов)

заменить название процедуры find_all_push_moves на push_move

Убрать aSearch и оставить только 'A*', просто добавив в 'A*' start(Start), steps(Sol,P).
+ добавить функцию <steps> к настройке предметной области.
+ добавить в 'A*' предикат <precomputation>, который добавляет настройки для поиска игры сокобана

При использовании в аргументе таких команд как asserta и др. предложений-правил их обязательно следует помещать в дополнительные скобки.

dfs вынести параметр N
mode(debug)
Функция нахождения списка априорных тупиков:
1. для начала найдем все тупики в игре (т.е. клетки, не являющиеся конечными позициями для бочек и переходы в которые делают невозможным дальнейшее перемещение бочек по карте - другими словами, создают невозможность решения уровня).
2. если все возможные переходы (!либо кроме одного!) из клетки A, не являющейся конечной, ведут в тупиковые состояния, не являющиеся конечными, то такая клетка становится тупиковой.

1. тестирование aSearch для частного случая
2. что не так с картой? (на нее влияет opt_path)

реализовать генератор уровней игры Сокобан (на вход строка, сост. из ['u','l','r','d','U','L','R','D'], на выход карта)
1. aSearch для перехода между двумя состояниями (для восстановления пути) (opt_path + next, h x2)
2. !!!В Open добавлять только те состояния, в которые мы попадаем толкнув коробку.
3. написать алгоритмы для pull distance
4. написать алгоритмы для assignment

добавить проверку на попадание в стиации:
1. передвижение ящика к стенке в положение не являющиеся конечным и слева и справа от новой позиции нет конечным позиций + ящик нельзя сдвинуть вперед, относительно текущего движения больше никак.
2. проверять позиции которые однозначно приводят к тупикам.

печатать и считывать решение в виде строки, а не в виде предиката
6. написать генератор уровней сокобан.
17. ускорить отрисовку карт.
3. убрать автоматическое добавление levels, чтобы удобнее было вводить путь к файлам.
9. написать предикат, который будет решать все уровни в папке.
написать фиксатор текущего состояния карты, т.е. чтобы можно было записать снимок в файл с именем map_snapshop
Разобраться как работает встроенный астар
добавить DEBUG mode для просмотра подробной статистики.

0. корректно реагирвать на файл с некорректными данными (Original lvls collection.txt) - у меня просто повисла программа
0. посмотреть в играх что можно выводить в debug
2. предварительно обозначить тупиковые места
2. позапускать программу takakena и попробовать извлечь исходный код
10. если есть несвязные области карты, в которых бочки стоят на своих местах, то при добавлении карты просто игнорировать их (не добавлять), и не выводить ошибку
11. 6/7 map(s) has been successfully added. - если ты добавляешь карту которая уже есть, тогда по сути мы добавляем (n-1) карту, а не n - учесть это и вывести сообщение, что мол такие-то карты были перезаписаны в процессе добавления.
12. записывать в файл время за которое решили задачу и moves/pushes (по желанию).
14. добавить отображение занятой памяти работы решателя
15. установить timeout
16. выбрать call_with_time_limit/3 или time_out/3 и прикрутить к ним catch
(не обязательно) преобразовать top/right в wall переписать тупик
заранее добавить непроходимые точки

. при добалении карт, выводить сообщения аля: "такого файла не существует" и если не удалось добавить карту, то какая именно ошибка возникла
. добавлять с перезаписью или нет
. если карта уже существует, то выводить сообщение о том что две карты имеют одинаковое имя
==================
. reachable_by_sokoban возвращать не кол-во шагов, а сам путь
почему redefine static procedure?!
!!! заменить consult на ensure_loaded !!! make\0
namespaces (:user) как вообще они работают: что за ?? с help:help(X) ~ helpfgdgdf:help(X)


?- catch(time_out(solve_map('test/test_7.pl'),15,R),E=time_limit_exceeded,(print_message(error,E),fail)).
ERROR: c:/users/andrew/desktop/swi prolog/sokoban/maps/test/test_7.pl:122:
        Unknown message: time_out
sol found
Pass: r u u u u u ...
m/p: 429/2
CPU time = 16 msec
R = success.